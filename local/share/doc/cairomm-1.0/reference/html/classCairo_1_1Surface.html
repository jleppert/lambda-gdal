<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>cairomm: Cairo::Surface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cairomm
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCairo.html">Cairo</a></li><li class="navelem"><a class="el" href="classCairo_1_1Surface.html">Surface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classCairo_1_1Surface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Cairo::Surface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A cairo surface represents an image, either as the destination of a drawing operation or as source when drawing onto another surface.  
 <a href="classCairo_1_1Surface.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Cairo::Surface:</div>
<div class="dyncontent">
<div class="center"><img src="classCairo_1_1Surface__inherit__graph.png" border="0" usemap="#Cairo_1_1Surface_inherit__map" alt="Inheritance graph"/></div>
<map name="Cairo_1_1Surface_inherit__map" id="Cairo_1_1Surface_inherit__map">
<area shape="rect" id="node2" href="classCairo_1_1GlitzSurface.html" title="A GlitzSurface provides a way to render to the X Window System using Glitz. " alt="" coords="195,5,335,32"/><area shape="rect" id="node3" href="classCairo_1_1ImageSurface.html" title="Image surfaces provide the ability to render to memory buffers either allocated by cairo or by the ca..." alt="" coords="189,56,341,83"/><area shape="rect" id="node4" href="classCairo_1_1PdfSurface.html" title="A PdfSurface provides a way to render PDF documents from cairo. " alt="" coords="199,107,331,133"/><area shape="rect" id="node5" href="classCairo_1_1PsSurface.html" title="A PsSurface provides a way to render PostScript documents from cairo. " alt="" coords="201,157,328,184"/><area shape="rect" id="node6" href="classCairo_1_1QuartzSurface.html" title="A QuartzSurface provides a way to render within Apple Mac OS X. " alt="" coords="187,208,342,235"/><area shape="rect" id="node7" href="classCairo_1_1SvgSurface.html" title="A SvgSurface provides a way to render Scalable Vector Graphics (SVG) images from cairo. " alt="" coords="197,259,333,285"/><area shape="rect" id="node8" href="classCairo_1_1Win32PrintingSurface.html" title="A multi&#45;page vector surface type for printing on Microsoft Windows. " alt="" coords="165,309,364,336"/><area shape="rect" id="node9" href="classCairo_1_1Win32Surface.html" title="A Win32Surface provides a way to render within Microsoft Windows. " alt="" coords="189,360,340,387"/><area shape="rect" id="node10" href="classCairo_1_1XlibSurface.html" title="An XlibSurface provides a way to render to the X Window System using XLib. " alt="" coords="197,411,332,437"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a02fb9416d466b762bc5845b0ae204f49"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; ErrorStatus, const unsigned char*, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a02fb9416d466b762bc5845b0ae204f49">SlotWriteFunc</a></td></tr>
<tr class="memdesc:a02fb9416d466b762bc5845b0ae204f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">For example: <code> ErrorStatus my_write_func(unsigned char* data, unsigned int length); </code>  <a href="#a02fb9416d466b762bc5845b0ae204f49">More...</a><br /></td></tr>
<tr class="separator:a02fb9416d466b762bc5845b0ae204f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66be8453e3fc558ea1282a911bf60e2"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; ErrorStatus, unsigned char*, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#af66be8453e3fc558ea1282a911bf60e2">SlotReadFunc</a></td></tr>
<tr class="memdesc:af66be8453e3fc558ea1282a911bf60e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of function which is called when a backend needs to read data from an input stream.  <a href="#af66be8453e3fc558ea1282a911bf60e2">More...</a><br /></td></tr>
<tr class="separator:af66be8453e3fc558ea1282a911bf60e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150d8ae84fa994f8e2032caa525c166a"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a150d8ae84fa994f8e2032caa525c166a">SlotDestroy</a></td></tr>
<tr class="memdesc:a150d8ae84fa994f8e2032caa525c166a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For instance, void on_destroy();.  <a href="#a150d8ae84fa994f8e2032caa525c166a">More...</a><br /></td></tr>
<tr class="separator:a150d8ae84fa994f8e2032caa525c166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad176eb7343b5902df3c19f9f56e59fb4"><td class="memItemLeft" align="right" valign="top">typedef cairo_surface_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a></td></tr>
<tr class="memdesc:ad176eb7343b5902df3c19f9f56e59fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying C cairo surface type.  <a href="#ad176eb7343b5902df3c19f9f56e59fb4">More...</a><br /></td></tr>
<tr class="separator:ad176eb7343b5902df3c19f9f56e59fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47b90669a5a85d187cc0d28dc99915c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a47b90669a5a85d187cc0d28dc99915c8">Surface</a> (cairo_surface_t*<a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>, bool has_reference=false)</td></tr>
<tr class="memdesc:a47b90669a5a85d187cc0d28dc99915c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a C++ wrapper for the C instance.  <a href="#a47b90669a5a85d187cc0d28dc99915c8">More...</a><br /></td></tr>
<tr class="separator:a47b90669a5a85d187cc0d28dc99915c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0d7fe23fdbf6aeab62cf240a1fb434"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a7d0d7fe23fdbf6aeab62cf240a1fb434">Surface</a> (const <a class="el" href="classCairo_1_1Surface.html">Surface</a>&amp;)=delete</td></tr>
<tr class="separator:a7d0d7fe23fdbf6aeab62cf240a1fb434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbdb807ef3cb8dae9181eb4f230d87e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCairo_1_1Surface.html">Surface</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#afcbdb807ef3cb8dae9181eb4f230d87e">operator=</a> (const <a class="el" href="classCairo_1_1Surface.html">Surface</a>&amp;)=delete</td></tr>
<tr class="separator:afcbdb807ef3cb8dae9181eb4f230d87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ca52e9e8e9a64358ff85e6ef0d93c1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a64ca52e9e8e9a64358ff85e6ef0d93c1">~Surface</a> ()</td></tr>
<tr class="separator:a64ca52e9e8e9a64358ff85e6ef0d93c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998e72aa2c251f96f450a168e16c87b6"><td class="memItemLeft" align="right" valign="top">const unsigned char*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a998e72aa2c251f96f450a168e16c87b6">get_mime_data</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; mime_type, unsigned long&amp; length)</td></tr>
<tr class="memdesc:a998e72aa2c251f96f450a168e16c87b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return mime data previously attached to surface using the specified mime type.  <a href="#a998e72aa2c251f96f450a168e16c87b6">More...</a><br /></td></tr>
<tr class="separator:a998e72aa2c251f96f450a168e16c87b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c572103fe56f7c6d0b83f2986338f82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a7c572103fe56f7c6d0b83f2986338f82">set_mime_data</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; mime_type, unsigned char* data, unsigned long length, const <a class="el" href="classCairo_1_1Surface.html#a150d8ae84fa994f8e2032caa525c166a">SlotDestroy</a>&amp; slot_destroy)</td></tr>
<tr class="memdesc:a7c572103fe56f7c6d0b83f2986338f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach an image in the format mime_type to surface.  <a href="#a7c572103fe56f7c6d0b83f2986338f82">More...</a><br /></td></tr>
<tr class="separator:a7c572103fe56f7c6d0b83f2986338f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5074b0c28c547802824d6d6cd2b0b8b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a5074b0c28c547802824d6d6cd2b0b8b5">unset_mime_data</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; mime_type)</td></tr>
<tr class="memdesc:a5074b0c28c547802824d6d6cd2b0b8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the data from a surface.  <a href="#a5074b0c28c547802824d6d6cd2b0b8b5">More...</a><br /></td></tr>
<tr class="separator:a5074b0c28c547802824d6d6cd2b0b8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3dd712e398719315bbd89efe9af0b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a7e3dd712e398719315bbd89efe9af0b2">get_font_options</a> (<a class="el" href="classCairo_1_1FontOptions.html">FontOptions</a>&amp; options) const </td></tr>
<tr class="memdesc:a7e3dd712e398719315bbd89efe9af0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the default font rendering options for the surface.  <a href="#a7e3dd712e398719315bbd89efe9af0b2">More...</a><br /></td></tr>
<tr class="separator:a7e3dd712e398719315bbd89efe9af0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8afee4ddb4935b85698f27099646a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a8d8afee4ddb4935b85698f27099646a0">finish</a> ()</td></tr>
<tr class="memdesc:a8d8afee4ddb4935b85698f27099646a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finishes the surface and drops all references to external resources.  <a href="#a8d8afee4ddb4935b85698f27099646a0">More...</a><br /></td></tr>
<tr class="separator:a8d8afee4ddb4935b85698f27099646a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f95678918fb40bae15f8aad2adb6ef2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a8f95678918fb40bae15f8aad2adb6ef2">flush</a> ()</td></tr>
<tr class="memdesc:a8f95678918fb40bae15f8aad2adb6ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do any pending drawing for the surface and also restore any temporary modifications cairo has made to the surface's state.  <a href="#a8f95678918fb40bae15f8aad2adb6ef2">More...</a><br /></td></tr>
<tr class="separator:a8f95678918fb40bae15f8aad2adb6ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b1f860cc55f4ad168e100108e0b7bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a77b1f860cc55f4ad168e100108e0b7bb">mark_dirty</a> ()</td></tr>
<tr class="memdesc:a77b1f860cc55f4ad168e100108e0b7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells cairo to consider the data buffer dirty.  <a href="#a77b1f860cc55f4ad168e100108e0b7bb">More...</a><br /></td></tr>
<tr class="separator:a77b1f860cc55f4ad168e100108e0b7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbf3a036b7dc7c09fc86996ea1ee61f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a1dbf3a036b7dc7c09fc86996ea1ee61f">mark_dirty</a> (int x, int y, int width, int height)</td></tr>
<tr class="memdesc:a1dbf3a036b7dc7c09fc86996ea1ee61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a rectangular area of the given surface dirty.  <a href="#a1dbf3a036b7dc7c09fc86996ea1ee61f">More...</a><br /></td></tr>
<tr class="separator:a1dbf3a036b7dc7c09fc86996ea1ee61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957e290a548d3cba65aa9e3fd0c86180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a957e290a548d3cba65aa9e3fd0c86180">set_device_offset</a> (double x_offset, double y_offset)</td></tr>
<tr class="memdesc:a957e290a548d3cba65aa9e3fd0c86180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface.  <a href="#a957e290a548d3cba65aa9e3fd0c86180">More...</a><br /></td></tr>
<tr class="separator:a957e290a548d3cba65aa9e3fd0c86180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5861783d0f5f3b396f52791a93e668fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a5861783d0f5f3b396f52791a93e668fe">get_device_offset</a> (double&amp; x_offset, double&amp; y_offset) const </td></tr>
<tr class="memdesc:a5861783d0f5f3b396f52791a93e668fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a previous device offset set by <a class="el" href="classCairo_1_1Surface.html#a957e290a548d3cba65aa9e3fd0c86180" title="Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface...">set_device_offset()</a>.  <a href="#a5861783d0f5f3b396f52791a93e668fe">More...</a><br /></td></tr>
<tr class="separator:a5861783d0f5f3b396f52791a93e668fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8caca30702fe2bd69ae89929ee784e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ac8caca30702fe2bd69ae89929ee784e8">set_fallback_resolution</a> (double x_pixels_per_inch, double y_pixels_per_inch)</td></tr>
<tr class="memdesc:ac8caca30702fe2bd69ae89929ee784e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the horizontal and vertical resolution for image fallbacks.  <a href="#ac8caca30702fe2bd69ae89929ee784e8">More...</a><br /></td></tr>
<tr class="separator:ac8caca30702fe2bd69ae89929ee784e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a8d5a2b5c91d11f7758d0a67f6093a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#aa3a8d5a2b5c91d11f7758d0a67f6093a">get_fallback_resolution</a> (double&amp; x_pixels_per_inch, double&amp; y_pixels_per_inch) const </td></tr>
<tr class="memdesc:aa3a8d5a2b5c91d11f7758d0a67f6093a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the previous fallback resolution set by <a class="el" href="classCairo_1_1Surface.html#ac8caca30702fe2bd69ae89929ee784e8" title="Set the horizontal and vertical resolution for image fallbacks. ">set_fallback_resolution()</a>, or default fallback resolution if never set.  <a href="#aa3a8d5a2b5c91d11f7758d0a67f6093a">More...</a><br /></td></tr>
<tr class="separator:aa3a8d5a2b5c91d11f7758d0a67f6093a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee0760ea1895f5e6c8f6673f83cc072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCairo.html#af11d962e38a38a2d92fc1473fbe92549">SurfaceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a7ee0760ea1895f5e6c8f6673f83cc072">get_type</a> () const </td></tr>
<tr class="separator:a7ee0760ea1895f5e6c8f6673f83cc072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe39669b1d4239f3e4f73a8bf5105a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCairo.html#a1f0f5d82599dfeabbeb2396dbfd767d0">Content</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a5fe39669b1d4239f3e4f73a8bf5105a5">get_content</a> () const </td></tr>
<tr class="memdesc:a5fe39669b1d4239f3e4f73a8bf5105a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the content type of surface which indicates whether the surface contains color and/or alpha information.  <a href="#a5fe39669b1d4239f3e4f73a8bf5105a5">More...</a><br /></td></tr>
<tr class="separator:a5fe39669b1d4239f3e4f73a8bf5105a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae22bcaa9becbf3ca703a380f70c2c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#aae22bcaa9becbf3ca703a380f70c2c0a">copy_page</a> ()</td></tr>
<tr class="memdesc:aae22bcaa9becbf3ca703a380f70c2c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the current page for backends that support multiple pages, but doesn't clear it, so that the contents of the current page will be retained for the next page.  <a href="#aae22bcaa9becbf3ca703a380f70c2c0a">More...</a><br /></td></tr>
<tr class="separator:aae22bcaa9becbf3ca703a380f70c2c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad318acd86c1875854ef4e1e2867052c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ad318acd86c1875854ef4e1e2867052c3">show_page</a> ()</td></tr>
<tr class="memdesc:ad318acd86c1875854ef4e1e2867052c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits and clears the current page for backends that support multiple pages.  <a href="#ad318acd86c1875854ef4e1e2867052c3">More...</a><br /></td></tr>
<tr class="separator:ad318acd86c1875854ef4e1e2867052c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e133bf758c85195db6d3ccfbe1d54a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ae4e133bf758c85195db6d3ccfbe1d54a">has_show_text_glyphs</a> () const </td></tr>
<tr class="memdesc:ae4e133bf758c85195db6d3ccfbe1d54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the surface supports sophisticated <a class="el" href="classCairo_1_1Context.html#a45723fd605cc2343ab46cf603d330002" title="This operation has rendering effects similar to show_glyphs() but, if the target surface supports it...">Context::show_text_glyphs()</a> operations.  <a href="#ae4e133bf758c85195db6d3ccfbe1d54a">More...</a><br /></td></tr>
<tr class="separator:ae4e133bf758c85195db6d3ccfbe1d54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153405d271814ab4d47b90a1c36d2370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a153405d271814ab4d47b90a1c36d2370">write_to_png</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; filename)</td></tr>
<tr class="memdesc:a153405d271814ab4d47b90a1c36d2370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the contents of surface to a new file filename as a PNG image.  <a href="#a153405d271814ab4d47b90a1c36d2370">More...</a><br /></td></tr>
<tr class="separator:a153405d271814ab4d47b90a1c36d2370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eca5bc13abe27f470fdf08134269bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ab3eca5bc13abe27f470fdf08134269bb">write_to_png_stream</a> (const <a class="el" href="classCairo_1_1Surface.html#a02fb9416d466b762bc5845b0ae204f49">SlotWriteFunc</a>&amp; write_func)</td></tr>
<tr class="memdesc:ab3eca5bc13abe27f470fdf08134269bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> to the write function.  <a href="#ab3eca5bc13abe27f470fdf08134269bb">More...</a><br /></td></tr>
<tr class="separator:ab3eca5bc13abe27f470fdf08134269bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83763b7906a666b095ce376271455457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a83763b7906a666b095ce376271455457">write_to_png</a> (cairo_write_func_t write_func, void* closure)</td></tr>
<tr class="separator:a83763b7906a666b095ce376271455457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1f19c2210e0e7a4aa3d3053b90107f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Device.html">Device</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a3d1f19c2210e0e7a4aa3d3053b90107f">get_device</a> ()</td></tr>
<tr class="memdesc:a3d1f19c2210e0e7a4aa3d3053b90107f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the device for a surface.  <a href="#a3d1f19c2210e0e7a4aa3d3053b90107f">More...</a><br /></td></tr>
<tr class="separator:a3d1f19c2210e0e7a4aa3d3053b90107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d8f600aedba416bb640ac841494bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a17d8f600aedba416bb640ac841494bde">cobj</a> ()</td></tr>
<tr class="memdesc:a17d8f600aedba416bb640ac841494bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides acces to the underlying C cairo surface.  <a href="#a17d8f600aedba416bb640ac841494bde">More...</a><br /></td></tr>
<tr class="separator:a17d8f600aedba416bb640ac841494bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45e0ec675af4bb7259df99d202ac83c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#af45e0ec675af4bb7259df99d202ac83c">cobj</a> () const </td></tr>
<tr class="memdesc:af45e0ec675af4bb7259df99d202ac83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides acces to the underlying C cairo surface.  <a href="#af45e0ec675af4bb7259df99d202ac83c">More...</a><br /></td></tr>
<tr class="separator:af45e0ec675af4bb7259df99d202ac83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac471fbf586ba579565c6d876f9164717"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ac471fbf586ba579565c6d876f9164717">create</a> (const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt; other, <a class="el" href="namespaceCairo.html#a1f0f5d82599dfeabbeb2396dbfd767d0">Content</a> content, int width, int height)</td></tr>
<tr class="memdesc:ac471fbf586ba579565c6d876f9164717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new surface that is as compatible as possible with an existing surface.  <a href="#ac471fbf586ba579565c6d876f9164717">More...</a><br /></td></tr>
<tr class="separator:ac471fbf586ba579565c6d876f9164717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9616c09e08857cef6f771545e55274"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a7d9616c09e08857cef6f771545e55274">create</a> (const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&amp; target, double x, double y, double width, double height)</td></tr>
<tr class="memdesc:a7d9616c09e08857cef6f771545e55274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new surface that is a rectangle within the target surface.  <a href="#a7d9616c09e08857cef6f771545e55274">More...</a><br /></td></tr>
<tr class="separator:a7d9616c09e08857cef6f771545e55274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8c9aea28f0d1f6c2dcb507a2c7bb027c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a8c9aea28f0d1f6c2dcb507a2c7bb027c">m_cobject</a></td></tr>
<tr class="memdesc:a8c9aea28f0d1f6c2dcb507a2c7bb027c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying C cairo surface type that is wrapped by this <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a>.  <a href="#a8c9aea28f0d1f6c2dcb507a2c7bb027c">More...</a><br /></td></tr>
<tr class="separator:a8c9aea28f0d1f6c2dcb507a2c7bb027c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A cairo surface represents an image, either as the destination of a drawing operation or as source when drawing onto another surface. </p>
<p>There are different subtypes of cairo surface for different drawing backends. This class is a base class for all subtypes and should not be used directly</p>
<p>Most surface types allow accessing the surface without using <a class="el" href="namespaceCairo.html">Cairo</a> functions. If you do this, keep in mind that it is mandatory that you call <a class="el" href="classCairo_1_1Surface.html#a8f95678918fb40bae15f8aad2adb6ef2" title="Do any pending drawing for the surface and also restore any temporary modifications cairo has made to...">Cairo::Surface::flush()</a> before reading from or writing to the surface and that you must use <a class="el" href="classCairo_1_1Surface.html#a77b1f860cc55f4ad168e100108e0b7bb" title="Tells cairo to consider the data buffer dirty. ">Cairo::Surface::mark_dirty()</a> after modifying it.</p>
<p>Surfaces are reference-counted objects that should be used via <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr<> is a reference-counting shared smartpointer. ">Cairo::RefPtr</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad176eb7343b5902df3c19f9f56e59fb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cairo_surface_t <a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">Cairo::Surface::cobject</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying C cairo surface type. </p>

</div>
</div>
<a class="anchor" id="a150d8ae84fa994f8e2032caa525c166a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;void&gt; <a class="el" href="classCairo_1_1Surface.html#a150d8ae84fa994f8e2032caa525c166a">Cairo::Surface::SlotDestroy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For instance, void on_destroy();. </p>

</div>
</div>
<a class="anchor" id="af66be8453e3fc558ea1282a911bf60e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;ErrorStatus, unsigned char* , unsigned int &gt; <a class="el" href="classCairo_1_1Surface.html#af66be8453e3fc558ea1282a911bf60e2">Cairo::Surface::SlotReadFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of function which is called when a backend needs to read data from an input stream. </p>
<p>It is passed the buffer to read the data into and the length of the data in bytes. The read function should return CAIRO_STATUS_SUCCESS if all the data was successfully read, CAIRO_STATUS_READ_ERROR otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the buffer into which to read the data </td></tr>
    <tr><td class="paramname">length</td><td>the amount of data to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the status code of the read operation </dd></dl>

</div>
</div>
<a class="anchor" id="a02fb9416d466b762bc5845b0ae204f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;ErrorStatus, const unsigned char* , unsigned int &gt; <a class="el" href="classCairo_1_1Surface.html#a02fb9416d466b762bc5845b0ae204f49">Cairo::Surface::SlotWriteFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For example: <code> ErrorStatus my_write_func(unsigned char* data, unsigned int length); </code> </p>
<p>This is the type of function which is called when a backend needs to write data to an output stream. It is passed the data to write and the length of the data in bytes. The write function should return CAIRO_STATUS_SUCCESS if all the data was successfully written, CAIRO_STATUS_WRITE_ERROR otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the buffer containing the data to write </td></tr>
    <tr><td class="paramname">length</td><td>the amount of data to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the status code of the write operation </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a47b90669a5a85d187cc0d28dc99915c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Cairo::Surface::Surface </td>
          <td>(</td>
          <td class="paramtype">cairo_surface_t *&#160;</td>
          <td class="paramname"><em>cobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_reference</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a C++ wrapper for the C instance. </p>
<p>This C++ instance should then be given to a <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr<> is a reference-counting shared smartpointer. ">RefPtr</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cobject</td><td>The C instance. </td></tr>
    <tr><td class="paramname">has_reference</td><td>Whether we already have a reference. Otherwise, the constructor will take an extra reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d0d7fe23fdbf6aeab62cf240a1fb434"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Cairo::Surface::Surface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1Surface.html">Surface</a>&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a64ca52e9e8e9a64358ff85e6ef0d93c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Cairo::Surface::~Surface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a17d8f600aedba416bb640ac841494bde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>* Cairo::Surface::cobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides acces to the underlying C cairo surface. </p>

</div>
</div>
<a class="anchor" id="af45e0ec675af4bb7259df99d202ac83c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>* Cairo::Surface::cobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides acces to the underlying C cairo surface. </p>

</div>
</div>
<a class="anchor" id="aae22bcaa9becbf3ca703a380f70c2c0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::copy_page </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits the current page for backends that support multiple pages, but doesn't clear it, so that the contents of the current page will be retained for the next page. </p>
<p>Use <a class="el" href="classCairo_1_1Surface.html#ad318acd86c1875854ef4e1e2867052c3" title="Emits and clears the current page for backends that support multiple pages. ">show_page()</a> if you want to get an empty page after the emission.</p>
<dl class="section since"><dt>Since</dt><dd>1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ac471fbf586ba579565c6d876f9164717"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt;<a class="el" href="classCairo_1_1Surface.html">Surface</a>&gt; Cairo::Surface::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceCairo.html#a1f0f5d82599dfeabbeb2396dbfd767d0">Content</a>&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new surface that is as compatible as possible with an existing surface. </p>
<p>The new surface will use the same backend as other unless that is not possible for some reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>an existing surface used to select the backend of the new surface </td></tr>
    <tr><td class="paramname">content</td><td>the content for the new surface </td></tr>
    <tr><td class="paramname">width</td><td>width of the new surface, (in device-space units) </td></tr>
    <tr><td class="paramname">height</td><td>height of the new surface (in device-space units) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr<> is a reference-counting shared smartpointer. ">RefPtr</a> to the newly allocated surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d9616c09e08857cef6f771545e55274"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt;<a class="el" href="classCairo_1_1Surface.html">Surface</a>&gt; Cairo::Surface::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new surface that is a rectangle within the target surface. </p>
<p>All operations drawn to this surface are then clipped and translated onto the target surface. Nothing drawn via this sub-surface outside of its bounds is drawn onto the target surface, making this a useful method for passing constrained child surfaces to library routines that draw directly onto the parent surface, i.e. with no further backend allocations, double buffering or copies.</p>
<p>The semantics of subsurfaces have not been finalized yet unless the rectangle is in full device units, is contained within the extents of the target surface, and the target or subsurface's device transforms are not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>an existing surface for which the sub-surface will point to </td></tr>
    <tr><td class="paramname">x</td><td>the x-origin of the sub-surface from the top-left of the target surface (in device-space units) </td></tr>
    <tr><td class="paramname">y</td><td>the y-origin of the sub-surface from the top-left of the target surface (in device-space units) </td></tr>
    <tr><td class="paramname">width</td><td>width of the sub-surface (in device-space units) </td></tr>
    <tr><td class="paramname">height</td><td>height of the sub-surface (in device-space units)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.10 </dd></dl>

</div>
</div>
<a class="anchor" id="a8d8afee4ddb4935b85698f27099646a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finishes the surface and drops all references to external resources. </p>
<p>For example, for the Xlib backend it means that cairo will no longer access the drawable, which can be freed. After calling <a class="el" href="classCairo_1_1Surface.html#a8d8afee4ddb4935b85698f27099646a0" title="This function finishes the surface and drops all references to external resources. ">finish()</a> the only valid operations on a surface are getting and setting user data and referencing and destroying it. Further drawing to the surface will not affect the surface but will instead trigger a CAIRO_STATUS_SURFACE_FINISHED error.</p>
<p>When the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> is destroyed, cairo will call <a class="el" href="classCairo_1_1Surface.html#a8d8afee4ddb4935b85698f27099646a0" title="This function finishes the surface and drops all references to external resources. ">finish()</a> if it hasn't been called already, before freeing the resources associated with the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a>. </p>

</div>
</div>
<a class="anchor" id="a8f95678918fb40bae15f8aad2adb6ef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do any pending drawing for the surface and also restore any temporary modifications cairo has made to the surface's state. </p>
<p>This function must be called before switching from drawing on the surface with cairo to drawing on it directly with native APIs. If the surface doesn't support direct access, then this function does nothing. </p>

</div>
</div>
<a class="anchor" id="a5fe39669b1d4239f3e4f73a8bf5105a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCairo.html#a1f0f5d82599dfeabbeb2396dbfd767d0">Content</a> Cairo::Surface::get_content </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the content type of surface which indicates whether the surface contains color and/or alpha information. </p>
<dl class="section since"><dt>Since</dt><dd>1.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a3d1f19c2210e0e7a4aa3d3053b90107f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt;<a class="el" href="classCairo_1_1Device.html">Device</a>&gt; Cairo::Surface::get_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the device for a surface. </p>
<dl class="section return"><dt>Returns</dt><dd>The device for this surface, or an empty <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr<> is a reference-counting shared smartpointer. ">RefPtr</a> if the surface has no associated device </dd></dl>

</div>
</div>
<a class="anchor" id="a5861783d0f5f3b396f52791a93e668fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::get_device_offset </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a previous device offset set by <a class="el" href="classCairo_1_1Surface.html#a957e290a548d3cba65aa9e3fd0c86180" title="Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface...">set_device_offset()</a>. </p>

</div>
</div>
<a class="anchor" id="aa3a8d5a2b5c91d11f7758d0a67f6093a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::get_fallback_resolution </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_pixels_per_inch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y_pixels_per_inch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the previous fallback resolution set by <a class="el" href="classCairo_1_1Surface.html#ac8caca30702fe2bd69ae89929ee784e8" title="Set the horizontal and vertical resolution for image fallbacks. ">set_fallback_resolution()</a>, or default fallback resolution if never set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_pixels_per_inch</td><td>horizontal pixels per inch </td></tr>
    <tr><td class="paramname">y_pixels_per_inch</td><td>vertical pixels per inch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a7e3dd712e398719315bbd89efe9af0b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::get_font_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCairo_1_1FontOptions.html">FontOptions</a>&amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the default font rendering options for the surface. </p>
<p>This allows display surfaces to report the correct subpixel order for rendering on them, print surfaces to disable hinting of metrics and so forth. The result can then be used with cairo_scaled_font_create().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>a <a class="el" href="classCairo_1_1FontOptions.html" title="The font options specify how fonts should be rendered. ">FontOptions</a> object into which to store the retrieved options. All existing values are overwritten </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a998e72aa2c251f96f450a168e16c87b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* Cairo::Surface::get_mime_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mime_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return mime data previously attached to surface using the specified mime type. </p>
<p>If no data has been attached with the given mime type then this returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mime_type</td><td>The MIME type of the image data. </td></tr>
    <tr><td class="paramname">length</td><td>This will be set to the length of the image data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The image data attached to the surface. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.10 </dd></dl>

</div>
</div>
<a class="anchor" id="a7ee0760ea1895f5e6c8f6673f83cc072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCairo.html#af11d962e38a38a2d92fc1473fbe92549">SurfaceType</a> Cairo::Surface::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4e133bf758c85195db6d3ccfbe1d54a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cairo::Surface::has_show_text_glyphs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the surface supports sophisticated <a class="el" href="classCairo_1_1Context.html#a45723fd605cc2343ab46cf603d330002" title="This operation has rendering effects similar to show_glyphs() but, if the target surface supports it...">Context::show_text_glyphs()</a> operations. </p>
<p>That is, whether it actually uses the provided text and cluster data to a <a class="el" href="classCairo_1_1Context.html#a45723fd605cc2343ab46cf603d330002" title="This operation has rendering effects similar to show_glyphs() but, if the target surface supports it...">Context::show_text_glyphs()</a> call.</p>
<p>Note: Even if this function returns FALSE, a <a class="el" href="classCairo_1_1Context.html#a45723fd605cc2343ab46cf603d330002" title="This operation has rendering effects similar to show_glyphs() but, if the target surface supports it...">Context::show_text_glyphs()</a> operation targeted at this surface will still succeed. It just will act like a <a class="el" href="classCairo_1_1Context.html#af51f2c2ff72e8af66abeea3d15d25553" title="A drawing operator that generates the shape from an array of glyphs, rendered according to the curren...">Context::show_glyphs()</a> operation. Users can use this function to avoid computing UTF-8 text and cluster mapping if the target surface does not use it.</p>
<dl class="section since"><dt>Since</dt><dd>1.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a77b1f860cc55f4ad168e100108e0b7bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::mark_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells cairo to consider the data buffer dirty. </p>
<p>In particular, if you've created an <a class="el" href="classCairo_1_1ImageSurface.html" title="Image surfaces provide the ability to render to memory buffers either allocated by cairo or by the ca...">ImageSurface</a> with a data buffer that you've allocated yourself and you draw to that data buffer using means other than cairo, you must call <a class="el" href="classCairo_1_1Surface.html#a77b1f860cc55f4ad168e100108e0b7bb" title="Tells cairo to consider the data buffer dirty. ">mark_dirty()</a> before doing any additional drawing to that surface with cairo.</p>
<p>Note that if you do draw to the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> outside of cairo, you must call <a class="el" href="classCairo_1_1Surface.html#a8f95678918fb40bae15f8aad2adb6ef2" title="Do any pending drawing for the surface and also restore any temporary modifications cairo has made to...">flush()</a> before doing the drawing. </p>

</div>
</div>
<a class="anchor" id="a1dbf3a036b7dc7c09fc86996ea1ee61f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::mark_dirty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks a rectangular area of the given surface dirty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X coordinate of dirty rectangle </td></tr>
    <tr><td class="paramname">y</td><td>Y coordinate of dirty rectangle </td></tr>
    <tr><td class="paramname">width</td><td>width of dirty rectangle </td></tr>
    <tr><td class="paramname">height</td><td>height of dirty rectangle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcbdb807ef3cb8dae9181eb4f230d87e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Surface.html">Surface</a>&amp; Cairo::Surface::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1Surface.html">Surface</a>&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a957e290a548d3cba65aa9e3fd0c86180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::set_device_offset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface. </p>
<p>One use case for this function is when we want to create a <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> that redirects drawing for a portion of an onscreen surface to an offscreen surface in a way that is completely invisible to the user of the cairo API. Setting a transformation via cairo_translate() isn't sufficient to do this, since functions like <a class="el" href="classCairo_1_1Context.html#a0c7acaaf16d4740cd7fee2298bf2b5c4" title="Transform a coordinate from device space to user space by multiplying the given point by the inverse ...">Cairo::Context::device_to_user()</a> will expose the hidden offset.</p>
<p>Note that the offset only affects drawing to the surface, not using the surface in a surface pattern.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_offset</td><td>the offset in the X direction, in device units </td></tr>
    <tr><td class="paramname">y_offset</td><td>the offset in the Y direction, in device units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8caca30702fe2bd69ae89929ee784e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::set_fallback_resolution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_pixels_per_inch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_pixels_per_inch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the horizontal and vertical resolution for image fallbacks. </p>
<p>When certain operations aren't supported natively by a backend, cairo will fallback by rendering operations to an image and then overlaying that image onto the output. For backends that are natively vector-oriented, this function can be used to set the resolution used for these image fallbacks, (larger values will result in more detailed images, but also larger file sizes).</p>
<p>Some examples of natively vector-oriented backends are the ps, pdf, and svg backends.</p>
<p>For backends that are natively raster-oriented, image fallbacks are still possible, but they are always performed at the native device resolution. So this function has no effect on those backends.</p>
<p>Note: The fallback resolution only takes effect at the time of completing a page (with <a class="el" href="classCairo_1_1Context.html#a525cac95b4d4c2abea12b82c433adba9" title="Emits and clears the current page for backends that support multiple pages. ">Context::show_page()</a> or <a class="el" href="classCairo_1_1Context.html#a7ccbeacb2a7f2d787b3daf31a69383fd" title="Emits the current page for backends that support multiple pages, but doesn&#39;t clear it...">Context::copy_page()</a>) so there is currently no way to have more than one fallback resolution in effect on a single page.</p>
<p>The default fallback resoultion is 300 pixels per inch in both dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_pixels_per_inch</td><td>Pixels per inch in the x direction </td></tr>
    <tr><td class="paramname">y_pixels_per_inch</td><td>Pixels per inch in the y direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.2 </dd></dl>

</div>
</div>
<a class="anchor" id="a7c572103fe56f7c6d0b83f2986338f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::set_mime_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mime_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1Surface.html#a150d8ae84fa994f8e2032caa525c166a">SlotDestroy</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach an image in the format mime_type to surface. </p>
<p>To remove the data from a surface, call <a class="el" href="classCairo_1_1Surface.html#a5074b0c28c547802824d6d6cd2b0b8b5" title="Remove the data from a surface. ">unset_mime_data()</a> with same mime type.</p>
<p>The attached image (or filename) data can later be used by backends which support it (currently: PDF, PS, SVG and Win32 Printing surfaces) to emit this data instead of making a snapshot of the surface. This approach tends to be faster and requires less memory and disk space.</p>
<p>The recognized MIME types are the following: CAIRO_MIME_TYPE_JPEG, CAIRO_MIME_TYPE_PNG, CAIRO_MIME_TYPE_JP2, CAIRO_MIME_TYPE_URI.</p>
<p>See corresponding backend surface docs for details about which MIME types it can handle. Caution: the associated MIME data will be discarded if you draw on the surface afterwards. Use this function with care.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mime_type</td><td>The MIME type of the image data. param data The image  to attach to the surface. param length The length of the image data. </td></tr>
    <tr><td class="paramname">slot_destroy</td><td>A callback slot that will be called when the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> no longer needs the data. For instance, when the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> is destroyed or when new image data is attached using the same MIME tpe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.10 </dd></dl>

</div>
</div>
<a class="anchor" id="ad318acd86c1875854ef4e1e2867052c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::show_page </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits and clears the current page for backends that support multiple pages. </p>
<p>Use <a class="el" href="classCairo_1_1Surface.html#aae22bcaa9becbf3ca703a380f70c2c0a" title="Emits the current page for backends that support multiple pages, but doesn&#39;t clear it...">copy_page()</a> if you don't want to clear the page.</p>
<dl class="section since"><dt>Since</dt><dd>1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a5074b0c28c547802824d6d6cd2b0b8b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::unset_mime_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mime_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the data from a surface. </p>
<p>See <a class="el" href="classCairo_1_1Surface.html#a7c572103fe56f7c6d0b83f2986338f82" title="Attach an image in the format mime_type to surface. ">set_mime_data()</a>. </p>

</div>
</div>
<a class="anchor" id="a153405d271814ab4d47b90a1c36d2370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::write_to_png </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the contents of surface to a new file filename as a PNG image. </p>
<dl class="section note"><dt>Note</dt><dd>For this function to be available, cairo must have been compiled with PNG support</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of a file to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83763b7906a666b095ce376271455457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::write_to_png </td>
          <td>(</td>
          <td class="paramtype">cairo_write_func_t&#160;</td>
          <td class="paramname"><em>write_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Use write_to_png_stream instead </dd></dl>

</div>
</div>
<a class="anchor" id="ab3eca5bc13abe27f470fdf08134269bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::write_to_png_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1Surface.html#a02fb9416d466b762bc5845b0ae204f49">SlotWriteFunc</a>&amp;&#160;</td>
          <td class="paramname"><em>write_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> to the write function. </p>
<dl class="section note"><dt>Note</dt><dd>For this function to be available, cairo must have been compiled with PNG support</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">write_func</td><td>The function to be called when the backend needs to write data to an output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.8 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8c9aea28f0d1f6c2dcb507a2c7bb027c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>* Cairo::Surface::m_cobject</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The underlying C cairo surface type that is wrapped by this <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cairomm/surface.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 21 2015 21:56:36 for cairomm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
