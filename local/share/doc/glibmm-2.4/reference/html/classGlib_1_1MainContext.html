<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>glibmm: Glib::MainContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.46.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGlib.html">Glib</a></li><li class="navelem"><a class="el" href="classGlib_1_1MainContext.html">MainContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGlib_1_1MainContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Glib::MainContext Class Reference<div class="ingroups"><a class="el" href="group__MainLoop.html">The Main Event Loop</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Main context.  
 <a href="classGlib_1_1MainContext.html#details">More...</a></p>

<p><code>#include &lt;glibmm/main.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1cbedd2b4d723f53cd98df1bb757f904"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classGlib_1_1MainContext.html">Glib::MainContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a1cbedd2b4d723f53cd98df1bb757f904">CppObjectType</a></td></tr>
<tr class="separator:a1cbedd2b4d723f53cd98df1bb757f904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2ea4035a4809198aecbc748b750495"><td class="memItemLeft" align="right" valign="top">typedef GMainContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ada2ea4035a4809198aecbc748b750495">BaseObjectType</a></td></tr>
<tr class="separator:ada2ea4035a4809198aecbc748b750495"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8eaedd89e2b7404ea364b2f8b4dfa0af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a8eaedd89e2b7404ea364b2f8b4dfa0af">MainContext</a> (const <a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&amp; other)=delete</td></tr>
<tr class="separator:a8eaedd89e2b7404ea364b2f8b4dfa0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112cc935c448383449b568056d806db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a112cc935c448383449b568056d806db6">operator=</a> (const <a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&amp; other)=delete</td></tr>
<tr class="separator:a112cc935c448383449b568056d806db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde2e29315da1239af998f1826ad5e88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#afde2e29315da1239af998f1826ad5e88">iteration</a> (bool may_block)</td></tr>
<tr class="memdesc:afde2e29315da1239af998f1826ad5e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a single iteration for the given main loop.  <a href="#afde2e29315da1239af998f1826ad5e88">More...</a><br /></td></tr>
<tr class="separator:afde2e29315da1239af998f1826ad5e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4631ab57318f39f3e15d98ac1aaa5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#acf4631ab57318f39f3e15d98ac1aaa5c">pending</a> ()</td></tr>
<tr class="memdesc:acf4631ab57318f39f3e15d98ac1aaa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any sources have pending events for the given context.  <a href="#acf4631ab57318f39f3e15d98ac1aaa5c">More...</a><br /></td></tr>
<tr class="separator:acf4631ab57318f39f3e15d98ac1aaa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5e60018f7549f064e71b34b1668020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a5a5e60018f7549f064e71b34b1668020">wakeup</a> ()</td></tr>
<tr class="memdesc:a5a5e60018f7549f064e71b34b1668020"><td class="mdescLeft">&#160;</td><td class="mdescRight">If context is currently waiting in a poll(), interrupt the poll(), and continue the iteration process.  <a href="#a5a5e60018f7549f064e71b34b1668020">More...</a><br /></td></tr>
<tr class="separator:a5a5e60018f7549f064e71b34b1668020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92ee9cfb192aa5eb6c2aa0841068bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc">acquire</a> ()</td></tr>
<tr class="memdesc:aa92ee9cfb192aa5eb6c2aa0841068bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to become the owner of the specified context.  <a href="#aa92ee9cfb192aa5eb6c2aa0841068bbc">More...</a><br /></td></tr>
<tr class="separator:aa92ee9cfb192aa5eb6c2aa0841068bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c3d19af76d4b32aeae9d2e4f5c230f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a68c3d19af76d4b32aeae9d2e4f5c230f">wait</a> (<a class="el" href="classGlib_1_1Cond.html">Glib::Cond</a>&amp; cond, <a class="el" href="classGlib_1_1Mutex.html">Glib::Mutex</a>&amp; mutex)</td></tr>
<tr class="memdesc:a68c3d19af76d4b32aeae9d2e4f5c230f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to become the owner of the specified context, as with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context. ">acquire()</a>.  <a href="#a68c3d19af76d4b32aeae9d2e4f5c230f">More...</a><br /></td></tr>
<tr class="separator:a68c3d19af76d4b32aeae9d2e4f5c230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb4cc661f4f5773138a733f4a2ed156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#abbb4cc661f4f5773138a733f4a2ed156">wait</a> (<a class="el" href="classGlib_1_1Threads_1_1Cond.html">Glib::Threads::Cond</a>&amp; cond, <a class="el" href="classGlib_1_1Threads_1_1Mutex.html">Glib::Threads::Mutex</a>&amp; mutex)</td></tr>
<tr class="memdesc:abbb4cc661f4f5773138a733f4a2ed156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to become the owner of the specified context, as with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context. ">acquire()</a>.  <a href="#abbb4cc661f4f5773138a733f4a2ed156">More...</a><br /></td></tr>
<tr class="separator:abbb4cc661f4f5773138a733f4a2ed156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2d9cdfa27cbe30026932de0526f730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ace2d9cdfa27cbe30026932de0526f730">release</a> ()</td></tr>
<tr class="memdesc:ace2d9cdfa27cbe30026932de0526f730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases ownership of a context previously acquired by this thread with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context. ">acquire()</a>.  <a href="#ace2d9cdfa27cbe30026932de0526f730">More...</a><br /></td></tr>
<tr class="separator:ace2d9cdfa27cbe30026932de0526f730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d1fccb3c1f5aab758d5eb1b3c15d6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#af6d1fccb3c1f5aab758d5eb1b3c15d6a">prepare</a> (int&amp; priority)</td></tr>
<tr class="memdesc:af6d1fccb3c1f5aab758d5eb1b3c15d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to poll sources within a main loop.  <a href="#af6d1fccb3c1f5aab758d5eb1b3c15d6a">More...</a><br /></td></tr>
<tr class="separator:af6d1fccb3c1f5aab758d5eb1b3c15d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1bdf8fcb0130152237e87942c89ee1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#abd1bdf8fcb0130152237e87942c89ee1">prepare</a> ()</td></tr>
<tr class="memdesc:abd1bdf8fcb0130152237e87942c89ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to poll sources within a main loop.  <a href="#abd1bdf8fcb0130152237e87942c89ee1">More...</a><br /></td></tr>
<tr class="separator:abd1bdf8fcb0130152237e87942c89ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e8976cec1ae4f5b5c30feea6094927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927">query</a> (int max_priority, int&amp; timeout, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &gt;&amp; fds)</td></tr>
<tr class="memdesc:a49e8976cec1ae4f5b5c30feea6094927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines information necessary to poll this main loop.  <a href="#a49e8976cec1ae4f5b5c30feea6094927">More...</a><br /></td></tr>
<tr class="separator:a49e8976cec1ae4f5b5c30feea6094927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8061ef816d51cc27372f016c683cc513"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a8061ef816d51cc27372f016c683cc513">check</a> (int max_priority, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &gt;&amp; fds)</td></tr>
<tr class="memdesc:a8061ef816d51cc27372f016c683cc513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes the results of polling back to the main loop.  <a href="#a8061ef816d51cc27372f016c683cc513">More...</a><br /></td></tr>
<tr class="separator:a8061ef816d51cc27372f016c683cc513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1f06dbac3bbf771c25ce76af0d4880"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a5c1f06dbac3bbf771c25ce76af0d4880">dispatch</a> ()</td></tr>
<tr class="memdesc:a5c1f06dbac3bbf771c25ce76af0d4880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches all pending sources.  <a href="#a5c1f06dbac3bbf771c25ce76af0d4880">More...</a><br /></td></tr>
<tr class="separator:a5c1f06dbac3bbf771c25ce76af0d4880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8383c8f1a1a03b904f9be608ad8eaaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ad8383c8f1a1a03b904f9be608ad8eaaf">set_poll_func</a> (GPollFunc poll_func)</td></tr>
<tr class="memdesc:ad8383c8f1a1a03b904f9be608ad8eaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function to use to handle polling of file descriptors.  <a href="#ad8383c8f1a1a03b904f9be608ad8eaaf">More...</a><br /></td></tr>
<tr class="separator:ad8383c8f1a1a03b904f9be608ad8eaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a0b1e31173e163f11053dbcf21b84c"><td class="memItemLeft" align="right" valign="top">GPollFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a34a0b1e31173e163f11053dbcf21b84c">get_poll_func</a> ()</td></tr>
<tr class="memdesc:a34a0b1e31173e163f11053dbcf21b84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the poll function set by g_main_context_set_poll_func().  <a href="#a34a0b1e31173e163f11053dbcf21b84c">More...</a><br /></td></tr>
<tr class="separator:a34a0b1e31173e163f11053dbcf21b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdbe7d102a781b6aded3cdda45fef34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a7cdbe7d102a781b6aded3cdda45fef34">add_poll</a> (<a class="el" href="classGlib_1_1PollFD.html">PollFD</a>&amp; fd, int priority)</td></tr>
<tr class="memdesc:a7cdbe7d102a781b6aded3cdda45fef34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a file descriptor to the set of file descriptors polled for this context.  <a href="#a7cdbe7d102a781b6aded3cdda45fef34">More...</a><br /></td></tr>
<tr class="separator:a7cdbe7d102a781b6aded3cdda45fef34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ea2db49dd93739599d19756c251627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a33ea2db49dd93739599d19756c251627">remove_poll</a> (<a class="el" href="classGlib_1_1PollFD.html">PollFD</a>&amp; fd)</td></tr>
<tr class="memdesc:a33ea2db49dd93739599d19756c251627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes file descriptor from the set of file descriptors to be polled for a particular context.  <a href="#a33ea2db49dd93739599d19756c251627">More...</a><br /></td></tr>
<tr class="separator:a33ea2db49dd93739599d19756c251627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51154582ff342993ff27fa0024ab38f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ab51154582ff342993ff27fa0024ab38f">invoke</a> (const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; bool &gt;&amp; slot, int priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ab51154582ff342993ff27fa0024ab38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a function in such a way that this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a> is owned during the invocation of <em>slot</em>.  <a href="#ab51154582ff342993ff27fa0024ab38f">More...</a><br /></td></tr>
<tr class="separator:ab51154582ff342993ff27fa0024ab38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf307c9028858449e932f5fff100d432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalTimeout.html">SignalTimeout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#adf307c9028858449e932f5fff100d432">signal_timeout</a> ()</td></tr>
<tr class="memdesc:adf307c9028858449e932f5fff100d432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>.  <a href="#adf307c9028858449e932f5fff100d432">More...</a><br /></td></tr>
<tr class="separator:adf307c9028858449e932f5fff100d432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a12990fb67f7b5c1ed61e36952dd827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalIdle.html">SignalIdle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a2a12990fb67f7b5c1ed61e36952dd827">signal_idle</a> ()</td></tr>
<tr class="memdesc:a2a12990fb67f7b5c1ed61e36952dd827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idle signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>.  <a href="#a2a12990fb67f7b5c1ed61e36952dd827">More...</a><br /></td></tr>
<tr class="separator:a2a12990fb67f7b5c1ed61e36952dd827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8a4283456eb9036cc09dc3aaf203dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalIO.html">SignalIO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a8c8a4283456eb9036cc09dc3aaf203dc">signal_io</a> ()</td></tr>
<tr class="memdesc:a8c8a4283456eb9036cc09dc3aaf203dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>.  <a href="#a8c8a4283456eb9036cc09dc3aaf203dc">More...</a><br /></td></tr>
<tr class="separator:a8c8a4283456eb9036cc09dc3aaf203dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab646f19ce79faa35d97e8af93e6ca6d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalChildWatch.html">SignalChildWatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ab646f19ce79faa35d97e8af93e6ca6d6">signal_child_watch</a> ()</td></tr>
<tr class="memdesc:ab646f19ce79faa35d97e8af93e6ca6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">child watch signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>.  <a href="#ab646f19ce79faa35d97e8af93e6ca6d6">More...</a><br /></td></tr>
<tr class="separator:ab646f19ce79faa35d97e8af93e6ca6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71499a662e6ac07590a0972b1b0eac64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a71499a662e6ac07590a0972b1b0eac64">reference</a> () const </td></tr>
<tr class="separator:a71499a662e6ac07590a0972b1b0eac64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eaf5d38c393770f150db7bad9a67f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a8eaf5d38c393770f150db7bad9a67f9e">unreference</a> () const </td></tr>
<tr class="separator:a8eaf5d38c393770f150db7bad9a67f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbf5178aca208161051097f034d3694"><td class="memItemLeft" align="right" valign="top">GMainContext*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a0fbf5178aca208161051097f034d3694">gobj</a> ()</td></tr>
<tr class="separator:a0fbf5178aca208161051097f034d3694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1814534a832aecafba4a790e7b5ca25d"><td class="memItemLeft" align="right" valign="top">const GMainContext*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a1814534a832aecafba4a790e7b5ca25d">gobj</a> () const </td></tr>
<tr class="separator:a1814534a832aecafba4a790e7b5ca25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a841522a3db9ceb73742f9f235c3d2b"><td class="memItemLeft" align="right" valign="top">GMainContext*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a3a841522a3db9ceb73742f9f235c3d2b">gobj_copy</a> () const </td></tr>
<tr class="separator:a3a841522a3db9ceb73742f9f235c3d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a31bd96bf707a21c8a3003337dd3af9c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a31bd96bf707a21c8a3003337dd3af9c4">create</a> ()</td></tr>
<tr class="memdesc:a31bd96bf707a21c8a3003337dd3af9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>.  <a href="#a31bd96bf707a21c8a3003337dd3af9c4">More...</a><br /></td></tr>
<tr class="separator:a31bd96bf707a21c8a3003337dd3af9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1502cbed045a9fb27d18c6975e1d255d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a1502cbed045a9fb27d18c6975e1d255d">get_default</a> ()</td></tr>
<tr class="memdesc:a1502cbed045a9fb27d18c6975e1d255d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default main context.  <a href="#a1502cbed045a9fb27d18c6975e1d255d">More...</a><br /></td></tr>
<tr class="separator:a1502cbed045a9fb27d18c6975e1d255d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ga043c5714afbad2745b27301dd58470a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MainLoop.html#ga043c5714afbad2745b27301dd58470a4">wrap</a> (GMainContext* gobject, bool take_copy=false)</td></tr>
<tr class="separator:ga043c5714afbad2745b27301dd58470a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main context. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ada2ea4035a4809198aecbc748b750495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef GMainContext <a class="el" href="classGlib_1_1MainContext.html#ada2ea4035a4809198aecbc748b750495">Glib::MainContext::BaseObjectType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1cbedd2b4d723f53cd98df1bb757f904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGlib_1_1MainContext.html">Glib::MainContext</a> <a class="el" href="classGlib_1_1MainContext.html#a1cbedd2b4d723f53cd98df1bb757f904">Glib::MainContext::CppObjectType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8eaedd89e2b7404ea364b2f8b4dfa0af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::MainContext::MainContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa92ee9cfb192aa5eb6c2aa0841068bbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::acquire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to become the owner of the specified context. </p>
<p>If some other thread is the owner of the context, returns <code>false</code> immediately. Ownership is properly recursive: the owner can require ownership again and will release ownership when <a class="el" href="classGlib_1_1MainContext.html#ace2d9cdfa27cbe30026932de0526f730" title="Releases ownership of a context previously acquired by this thread with acquire(). ">release()</a> is called as many times as <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context. ">acquire()</a>. You must be the owner of a context before you can call <a class="el" href="classGlib_1_1MainContext.html#abd1bdf8fcb0130152237e87942c89ee1" title="Prepares to poll sources within a main loop. ">prepare()</a>, <a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927" title="Determines information necessary to poll this main loop. ">query()</a>, <a class="el" href="classGlib_1_1MainContext.html#a8061ef816d51cc27372f016c683cc513" title="Passes the results of polling back to the main loop. ">check()</a>, <a class="el" href="classGlib_1_1MainContext.html#a5c1f06dbac3bbf771c25ce76af0d4880" title="Dispatches all pending sources. ">dispatch()</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, and this thread is now the owner of context. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cdbe7d102a781b6aded3cdda45fef34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::add_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1PollFD.html">PollFD</a>&amp;&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a file descriptor to the set of file descriptors polled for this context. </p>
<p>This will very seldomly be used directly. Instead a typical event source will use <a class="el" href="classGlib_1_1Source.html#a3a0843a960cad7a25919a682c37c9d03" title="Adds a file descriptor to the set of file descriptors polled for this source. ">Glib::Source::add_poll()</a> instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> structure holding information about a file descriptor to watch. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority for this file descriptor which should be the same as the priority used for <a class="el" href="classGlib_1_1Source.html#a77c4b83960b2fd8d65b10ade1fc2e2fb" title="Adds a Source to a context so that it will be executed within that context. ">Glib::Source::attach()</a> to ensure that the file descriptor is polled whenever the results may be needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8061ef816d51cc27372f016c683cc513"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::check </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>fds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passes the results of polling back to the main loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_priority</td><td>Maximum numerical priority of sources to check. </td></tr>
    <tr><td class="paramname">fds</td><td>Vector of <a class="el" href="classGlib_1_1PollFD.html">Glib::PollFD</a>'s that was passed to the last call to <a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927" title="Determines information necessary to poll this main loop. ">query()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if some sources are ready to be dispatched. </dd></dl>

</div>
</div>
<a class="anchor" id="a31bd96bf707a21c8a3003337dd3af9c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&gt; Glib::MainContext::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c1f06dbac3bbf771c25ce76af0d4880"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::dispatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatches all pending sources. </p>

</div>
</div>
<a class="anchor" id="a1502cbed045a9fb27d18c6975e1d255d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&gt; Glib::MainContext::get_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default main context. </p>
<p>This is the main context used for main loop functions when a main loop is not explicitly specified. </p><dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a34a0b1e31173e163f11053dbcf21b84c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GPollFunc Glib::MainContext::get_poll_func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the poll function set by g_main_context_set_poll_func(). </p>
<dl class="section return"><dt>Returns</dt><dd>The poll function </dd></dl>

</div>
</div>
<a class="anchor" id="a0fbf5178aca208161051097f034d3694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GMainContext* Glib::MainContext::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1814534a832aecafba4a790e7b5ca25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GMainContext* Glib::MainContext::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a841522a3db9ceb73742f9f235c3d2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GMainContext* Glib::MainContext::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab51154582ff342993ff27fa0024ab38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::invoke </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes a function in such a way that this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a> is owned during the invocation of <em>slot</em>. </p>
<p>If the context is owned by the current thread, <em>slot</em> is called directly. Otherwise, if the context is the thread-default main context of the current thread and <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context. ">acquire()</a> succeeds, then <em>slot</em> is called and <a class="el" href="classGlib_1_1MainContext.html#ace2d9cdfa27cbe30026932de0526f730" title="Releases ownership of a context previously acquired by this thread with acquire(). ">release()</a> is called afterwards.</p>
<p>In any other case, an idle source is created to call <em>slot</em> and that source is attached to the context (presumably to be run in another thread).</p>
<p>Note that, as with normal idle functions, <em>slot</em> should probably return <code>false</code>. If it returns <code>true</code>, it will be continuously run in a loop (and may prevent this call from returning).</p>
<p>If an idle source is created to call <em>slot</em>, <a class="el" href="classGlib_1_1MainContext.html#ab51154582ff342993ff27fa0024ab38f" title="Invokes a function in such a way that this MainContext is owned during the invocation of slot...">invoke()</a> may return before <em>slot</em> is called.</p>
<p>Because <a class="elRef" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html">sigc::trackable</a> is not thread-safe, if the slot represents a non-static method of a class deriving from <a class="elRef" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html">sigc::trackable</a>, and the slot is created by <a class="elRef" href="../../../libsigc++-2.0/reference/html/group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">sigc::mem_fun()</a>, <a class="el" href="classGlib_1_1MainContext.html#ab51154582ff342993ff27fa0024ab38f" title="Invokes a function in such a way that this MainContext is owned during the invocation of slot...">invoke()</a> should only be called from the thread where the context runs. You can use, say, boost::bind() or, in C++11, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01682.html#ga4c3052b337dde285bace96cbb996055c">std::bind()</a> or a C++11 lambda expression instead of <a class="elRef" href="../../../libsigc++-2.0/reference/html/group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">sigc::mem_fun()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A slot to call. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the idle source, if one is created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000002">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afde2e29315da1239af998f1826ad5e88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::iteration </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>may_block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a single iteration for the given main loop. </p>
<p>This involves checking to see if any event sources are ready to be processed, then if no events sources are ready and may_block is true, waiting for a source to become ready, then dispatching the highest priority events sources that are ready. Note that even when may_block is true, it is still possible for <a class="el" href="classGlib_1_1MainContext.html#afde2e29315da1239af998f1826ad5e88" title="Runs a single iteration for the given main loop. ">iteration()</a> to return false, since the the wait may be interrupted for other reasons than an event source becoming ready. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">may_block</td><td>Whether the call may block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if events were dispatched. </dd></dl>

</div>
</div>
<a class="anchor" id="a112cc935c448383449b568056d806db6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&amp; Glib::MainContext::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf4631ab57318f39f3e15d98ac1aaa5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::pending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any sources have pending events for the given context. </p>
<dl class="section return"><dt>Returns</dt><dd>true if events are pending. </dd></dl>

</div>
</div>
<a class="anchor" id="af6d1fccb3c1f5aab758d5eb1b3c15d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::prepare </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares to poll sources within a main loop. </p>
<p>The resulting information for polling is determined by calling <a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927" title="Determines information necessary to poll this main loop. ">query()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>Location to store priority of highest priority source already ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if some source is ready to be dispatched prior to polling. </dd></dl>

</div>
</div>
<a class="anchor" id="abd1bdf8fcb0130152237e87942c89ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::prepare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares to poll sources within a main loop. </p>
<p>The resulting information for polling is determined by calling <a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927" title="Determines information necessary to poll this main loop. ">query()</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if some source is ready to be dispatched prior to polling. </dd></dl>

</div>
</div>
<a class="anchor" id="a49e8976cec1ae4f5b5c30feea6094927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::query </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>fds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines information necessary to poll this main loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_priority</td><td>Maximum priority source to check. </td></tr>
    <tr><td class="paramname">timeout</td><td>Location to store timeout to be used in polling. </td></tr>
    <tr><td class="paramname">fds</td><td>Location to store <a class="el" href="classGlib_1_1PollFD.html">Glib::PollFD</a> records that need to be polled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of records actually stored in fds, or, if more than n_fds records need to be stored, the number of records that need to be stored. </dd></dl>

</div>
</div>
<a class="anchor" id="a71499a662e6ac07590a0972b1b0eac64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ace2d9cdfa27cbe30026932de0526f730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases ownership of a context previously acquired by this thread with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context. ">acquire()</a>. </p>
<p>If the context was acquired multiple times, the only release ownership when <a class="el" href="classGlib_1_1MainContext.html#ace2d9cdfa27cbe30026932de0526f730" title="Releases ownership of a context previously acquired by this thread with acquire(). ">release()</a> is called as many times as it was acquired. </p>

</div>
</div>
<a class="anchor" id="a33ea2db49dd93739599d19756c251627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::remove_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1PollFD.html">PollFD</a>&amp;&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes file descriptor from the set of file descriptors to be polled for a particular context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> structure holding information about a file descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8383c8f1a1a03b904f9be608ad8eaaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::set_poll_func </td>
          <td>(</td>
          <td class="paramtype">GPollFunc&#160;</td>
          <td class="paramname"><em>poll_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the function to use to handle polling of file descriptors. </p>
<p>It will be used instead of the poll() system call (or GLib's replacement function, which is used where poll() isn't available). This function could possibly be used to integrate the GLib event loop with an external event loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll_func</td><td>The function to call to poll all file descriptors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab646f19ce79faa35d97e8af93e6ca6d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalChildWatch.html">SignalChildWatch</a> Glib::MainContext::signal_child_watch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>child watch signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A signal proxy; you want to use <a class="el" href="classGlib_1_1SignalChildWatch.html#a4c2f5be316b9600133129cc974b6b5bb" title="Connects a child watch handler. ">SignalChildWatch::connect()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a12990fb67f7b5c1ed61e36952dd827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalIdle.html">SignalIdle</a> Glib::MainContext::signal_idle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Idle signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A signal proxy; you want to use <a class="el" href="classGlib_1_1SignalIdle.html#ac8befbaf1d10a17d1f3f75143e967a3f" title="Connects an idle handler. ">SignalIdle::connect()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c8a4283456eb9036cc09dc3aaf203dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalIO.html">SignalIO</a> Glib::MainContext::signal_io </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A signal proxy; you want to use <a class="el" href="classGlib_1_1SignalIO.html#ac205b21234d26094e75e0931c968c5d2" title="Connects an I/O handler that watches a file descriptor. ">SignalIO::connect()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="adf307c9028858449e932f5fff100d432"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalTimeout.html">SignalTimeout</a> Glib::MainContext::signal_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timeout signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A signal proxy; you want to use <a class="el" href="classGlib_1_1SignalTimeout.html#a75b555ed13d91e6903e927f9e0d7afd2" title="Connects a timeout handler. ">SignalTimeout::connect()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8eaf5d38c393770f150db7bad9a67f9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::unreference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a68c3d19af76d4b32aeae9d2e4f5c230f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1Cond.html">Glib::Cond</a>&amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1Mutex.html">Glib::Mutex</a>&amp;&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to become the owner of the specified context, as with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context. ">acquire()</a>. </p>
<p>But if another thread is the owner, atomically drop mutex and wait on cond until that owner releases ownership or until cond is signaled, then try again (once) to become the owner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable. </td></tr>
    <tr><td class="paramname">mutex</td><td>A mutex, currently held. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, and this thread is now the owner of context.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Use <a class="el" href="classGlib_1_1MainContext.html#abbb4cc661f4f5773138a733f4a2ed156" title="Tries to become the owner of the specified context, as with acquire(). ">wait(Glib::Threads::Cond&amp; cond, Glib::Threads::Mutex&amp; mutex)</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="abbb4cc661f4f5773138a733f4a2ed156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1Threads_1_1Cond.html">Glib::Threads::Cond</a>&amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1Threads_1_1Mutex.html">Glib::Threads::Mutex</a>&amp;&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to become the owner of the specified context, as with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context. ">acquire()</a>. </p>
<p>But if another thread is the owner, atomically drop mutex and wait on cond until that owner releases ownership or until cond is signaled, then try again (once) to become the owner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable. </td></tr>
    <tr><td class="paramname">mutex</td><td>A mutex, currently held. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, and this thread is now the owner of context. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a5e60018f7549f064e71b34b1668020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::wakeup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If context is currently waiting in a poll(), interrupt the poll(), and continue the iteration process. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 22 2015 11:30:21 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
