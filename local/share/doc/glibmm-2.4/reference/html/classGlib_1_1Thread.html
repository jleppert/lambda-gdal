<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>glibmm: Glib::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.46.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGlib.html">Glib</a></li><li class="navelem"><a class="el" href="classGlib_1_1Thread.html">Thread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGlib_1_1Thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Glib::Thread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a running thread.  
 <a href="classGlib_1_1Thread.html#details">More...</a></p>

<p><code>#include &lt;glibmm/thread.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread_1_1Exit.html">Exit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class used to exit from a thread.  <a href="classGlib_1_1Thread_1_1Exit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a864142ac3a938082cbf9001e29358930"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a864142ac3a938082cbf9001e29358930">Thread</a> (const <a class="el" href="classGlib_1_1Thread.html">Thread</a>&amp;)=delete</td></tr>
<tr class="separator:a864142ac3a938082cbf9001e29358930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87df11cc0a123efafb01a5407af1633a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1Thread.html">Thread</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a87df11cc0a123efafb01a5407af1633a">operator=</a> (const <a class="el" href="classGlib_1_1Thread.html">Thread</a>&amp;)=delete</td></tr>
<tr class="separator:a87df11cc0a123efafb01a5407af1633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95e51699279fd84c9577c45d76b0d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#ab95e51699279fd84c9577c45d76b0d8e">join</a> ()</td></tr>
<tr class="memdesc:ab95e51699279fd84c9577c45d76b0d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the thread finishes.  <a href="#ab95e51699279fd84c9577c45d76b0d8e">More...</a><br /></td></tr>
<tr class="separator:ab95e51699279fd84c9577c45d76b0d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9feee4b860d9928f86b9d255e2f2b133"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a9feee4b860d9928f86b9d255e2f2b133">joinable</a> () const </td></tr>
<tr class="memdesc:a9feee4b860d9928f86b9d255e2f2b133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the thread is joinable.  <a href="#a9feee4b860d9928f86b9d255e2f2b133">More...</a><br /></td></tr>
<tr class="separator:a9feee4b860d9928f86b9d255e2f2b133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b323f981147d7eb4b4bd03f3fbdccf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a3b323f981147d7eb4b4bd03f3fbdccf5">set_priority</a> (<a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a> priority)</td></tr>
<tr class="memdesc:a3b323f981147d7eb4b4bd03f3fbdccf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the priority of the thread to <em>priority</em>.  <a href="#a3b323f981147d7eb4b4bd03f3fbdccf5">More...</a><br /></td></tr>
<tr class="separator:a3b323f981147d7eb4b4bd03f3fbdccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d1bcf53d846b8b0d75b93178a614ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a28d1bcf53d846b8b0d75b93178a614ab">get_priority</a> () const </td></tr>
<tr class="memdesc:a28d1bcf53d846b8b0d75b93178a614ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the priority of the thread.  <a href="#a28d1bcf53d846b8b0d75b93178a614ab">More...</a><br /></td></tr>
<tr class="separator:a28d1bcf53d846b8b0d75b93178a614ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fbc6c46928a90d82114fa9b6b63196"><td class="memItemLeft" align="right" valign="top">GThread*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a28fbc6c46928a90d82114fa9b6b63196">gobj</a> ()</td></tr>
<tr class="separator:a28fbc6c46928a90d82114fa9b6b63196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351fa5fb621a394e28037c4f50ab69ad"><td class="memItemLeft" align="right" valign="top">const GThread*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a351fa5fb621a394e28037c4f50ab69ad">gobj</a> () const </td></tr>
<tr class="separator:a351fa5fb621a394e28037c4f50ab69ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2775df2f24b6166e3fab41e69dcd04b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a2775df2f24b6166e3fab41e69dcd04b6">create</a> (const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; slot, bool <a class="el" href="classGlib_1_1Thread.html#a9feee4b860d9928f86b9d255e2f2b133">joinable</a>=true)</td></tr>
<tr class="memdesc:a2775df2f24b6166e3fab41e69dcd04b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread with the priority <code>THREAD_PRIORITY_NORMAL</code>.  <a href="#a2775df2f24b6166e3fab41e69dcd04b6">More...</a><br /></td></tr>
<tr class="separator:a2775df2f24b6166e3fab41e69dcd04b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db6864c35701b1c179f48217ab76cca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a9db6864c35701b1c179f48217ab76cca">self</a> ()</td></tr>
<tr class="memdesc:a9db6864c35701b1c179f48217ab76cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Thread* corresponding to the calling thread.  <a href="#a9db6864c35701b1c179f48217ab76cca">More...</a><br /></td></tr>
<tr class="separator:a9db6864c35701b1c179f48217ab76cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30a7a8b037c7c7a3802aa2a22cf612d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#af30a7a8b037c7c7a3802aa2a22cf612d">create</a> (const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; slot, unsigned long stack_size, bool <a class="el" href="classGlib_1_1Thread.html#a9feee4b860d9928f86b9d255e2f2b133">joinable</a>, bool bound, <a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a> priority)</td></tr>
<tr class="memdesc:af30a7a8b037c7c7a3802aa2a22cf612d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread with the priority <em>priority</em>.  <a href="#af30a7a8b037c7c7a3802aa2a22cf612d">More...</a><br /></td></tr>
<tr class="separator:af30a7a8b037c7c7a3802aa2a22cf612d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad8be7a8093ef3aca32344264461011"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#acad8be7a8093ef3aca32344264461011">yield</a> ()</td></tr>
<tr class="memdesc:acad8be7a8093ef3aca32344264461011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives way to other threads waiting to be scheduled.  <a href="#acad8be7a8093ef3aca32344264461011">More...</a><br /></td></tr>
<tr class="separator:acad8be7a8093ef3aca32344264461011"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a6bfbb3119eaac9fa8cb725aa1e82f61e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1Thread.html">Thread</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Thread.html#a6bfbb3119eaac9fa8cb725aa1e82f61e">wrap</a> (GThread* gobject)</td></tr>
<tr class="separator:a6bfbb3119eaac9fa8cb725aa1e82f61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a running thread. </p>
<p>An instance of this class can only be obtained with <a class="el" href="classGlib_1_1Thread.html#a2775df2f24b6166e3fab41e69dcd04b6" title="Creates a new thread with the priority THREAD_PRIORITY_NORMAL. ">create()</a>, <a class="el" href="classGlib_1_1Thread.html#a9db6864c35701b1c179f48217ab76cca" title="Returns the Thread* corresponding to the calling thread. ">self()</a>, or <a class="el" href="classGlib_1_1Thread.html#a6bfbb3119eaac9fa8cb725aa1e82f61e">wrap(GThread*)</a>. It's not possible to delete a <a class="el" href="classGlib_1_1Thread.html" title="Represents a running thread. ">Thread</a> object. If the thread is <em>not</em> joinable, its resources will be freed automatically when it exits. Otherwise, if the thread <em>is</em> joinable, you must call <a class="el" href="classGlib_1_1Thread.html#ab95e51699279fd84c9577c45d76b0d8e" title="Waits until the thread finishes. ">join()</a> to avoid a memory leak.</p>
<dl class="section note"><dt>Note</dt><dd>g_thread_exit() is not wrapped, because that function exits a thread without any cleanup. That's especially dangerous in C++ code, since the destructors of automatic objects won't be invoked. Instead, you can throw a <a class="el" href="classGlib_1_1Thread_1_1Exit.html" title="Exception class used to exit from a thread. ">Thread::Exit</a> exception, which will be caught by the internal thread entry function.</dd>
<dd>
You might have noticed that the thread entry slot doesn't have the usual void* return value. If you want to return any data from your thread you can pass an additional output argument to the thread's entry slot.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use <a class="el" href="classGlib_1_1Threads_1_1Thread.html" title="Represents a running thread. ">Glib::Threads::Thread</a> instead. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a864142ac3a938082cbf9001e29358930"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1Thread.html">Thread</a>&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2775df2f24b6166e3fab41e69dcd04b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>* Glib::Thread::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>joinable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new thread with the priority <code>THREAD_PRIORITY_NORMAL</code>. </p>
<p>If <em>joinable</em> is <code>true</code>, you can wait for this thread's termination by calling <a class="el" href="classGlib_1_1Thread.html#ab95e51699279fd84c9577c45d76b0d8e" title="Waits until the thread finishes. ">join()</a>. Otherwise the thread will just disappear, when ready.</p>
<p>The new thread executes the function or method <em>slot</em> points to. You can pass additional arguments using <a class="elRef" href="../../../libsigc++-2.0/reference/html/group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4">sigc::bind()</a>. If the thread was created successfully, it is returned, otherwise a <a class="el" href="classGlib_1_1ThreadError.html" title="Exception class for thread-related errors. ">ThreadError</a> exception is thrown.</p>
<p>Because <a class="elRef" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html">sigc::trackable</a> is not thread safe, if the slot represents a non-static class method (that is, it is created by <a class="elRef" href="../../../libsigc++-2.0/reference/html/group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">sigc::mem_fun()</a>), the class concerned should not derive from <a class="elRef" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html">sigc::trackable</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A slot to execute in the new thread. </td></tr>
    <tr><td class="paramname">joinable</td><td>This parameter is now ignored because <a class="el" href="namespaceGlib_1_1Threads.html">Threads</a> are now always joinable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new Thread* on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ThreadError.html" title="Exception class for thread-related errors. ">Glib::ThreadError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af30a7a8b037c7c7a3802aa2a22cf612d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>* Glib::Thread::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>joinable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new thread with the priority <em>priority</em>. </p>
<p>The stack gets the size <em>stack_size</em> or the default value for the current platform, if <em>stack_size</em> is <code>0</code>.</p>
<p>If <em>joinable</em> is <code>true</code>, you can wait for this thread's termination by calling <a class="el" href="classGlib_1_1Thread.html#ab95e51699279fd84c9577c45d76b0d8e" title="Waits until the thread finishes. ">join()</a>. Otherwise the thread will just disappear, when ready. If <em>bound</em> is <code>true</code>, this thread will be scheduled in the system scope, otherwise the implementation is free to do scheduling in the process scope. The first variant is more expensive resource-wise, but generally faster. On some systems (e.g. Linux) all threads are bound.</p>
<p>The new thread executes the function or method <em>slot</em> points to. You can pass additional arguments using <a class="elRef" href="../../../libsigc++-2.0/reference/html/group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4">sigc::bind()</a>. If the thread was created successfully, it is returned.</p>
<p>Because <a class="elRef" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html">sigc::trackable</a> is not thread safe, if the slot represents a non-static class method (that is, it is created by <a class="elRef" href="../../../libsigc++-2.0/reference/html/group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">sigc::mem_fun()</a>), the class concerned should not derive from <a class="elRef" href="../../../libsigc++-2.0/reference/html/structsigc_1_1trackable.html">sigc::trackable</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It is not guaranteed, that threads with different priorities really behave accordingly. On some systems (e.g. Linux) only root can increase priorities. On other systems (e.g. Solaris) there doesn't seem to be different scheduling for different priorities. All in all try to avoid being dependent on priorities. Use <code><a class="el" href="namespaceGlib.html#ga9b87dca6496b6ad53baec9ca01318448a6216bb25baaaca32642841ade911a92e" title="The default priority. ">Glib::THREAD_PRIORITY_NORMAL</a></code> here as a default.</dd>
<dd>
Only use the extended <a class="el" href="classGlib_1_1Thread.html#af30a7a8b037c7c7a3802aa2a22cf612d" title="Creates a new thread with the priority priority. ">create(const sigc::slot&lt;void&gt;&amp;, unsigned long, bool, bool, ThreadPriority)</a> function, when you really can't use the simple <a class="el" href="classGlib_1_1Thread.html#a2775df2f24b6166e3fab41e69dcd04b6" title="Creates a new thread with the priority THREAD_PRIORITY_NORMAL. ">create(const sigc::slot&lt;void&gt;&amp;, bool)</a> instead. The latter overload does not take <em>stack_size</em>, <em>bound</em> and <em>priority</em> as arguments, as they should only be used for cases, where it is inevitable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A slot to execute in the new thread. </td></tr>
    <tr><td class="paramname">stack_size</td><td>A stack size for the new thread, or <code>0</code>. </td></tr>
    <tr><td class="paramname">joinable</td><td>Should this thread be joinable? </td></tr>
    <tr><td class="paramname">bound</td><td>Should this thread be bound to a system thread? </td></tr>
    <tr><td class="paramname">priority</td><td>A priority for the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new Thread* on success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ThreadError.html" title="Exception class for thread-related errors. ">Glib::ThreadError</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use the simpler <a class="el" href="classGlib_1_1Thread.html#a2775df2f24b6166e3fab41e69dcd04b6" title="Creates a new thread with the priority THREAD_PRIORITY_NORMAL. ">create()</a> method instead, because all <a class="el" href="namespaceGlib_1_1Threads.html">Threads</a> are now joinable, and bounds and priority parameters now have no effect. </dd></dl>

</div>
</div>
<a class="anchor" id="a28d1bcf53d846b8b0d75b93178a614ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a> Glib::Thread::get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the priority of the thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The thread's priority.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd><a class="el" href="classGlib_1_1Thread.html" title="Represents a running thread. ">Thread</a> priorities no longer have any effect. </dd></dl>

</div>
</div>
<a class="anchor" id="a28fbc6c46928a90d82114fa9b6b63196"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GThread* Glib::Thread::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a351fa5fb621a394e28037c4f50ab69ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GThread* Glib::Thread::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab95e51699279fd84c9577c45d76b0d8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Thread::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until the thread finishes. </p>
<p>Waits until the thread finishes, i.e. the slot, as given to <a class="el" href="classGlib_1_1Thread.html#a2775df2f24b6166e3fab41e69dcd04b6" title="Creates a new thread with the priority THREAD_PRIORITY_NORMAL. ">create()</a>, returns or g_thread_exit() is called by the thread. (Calling g_thread_exit() in a C++ program should be avoided.) All resources of the thread including the <a class="el" href="classGlib_1_1Thread.html" title="Represents a running thread. ">Glib::Thread</a> object are released. The thread must have been created with <code>joinable&#160;=&#160;true</code>. </p>

</div>
</div>
<a class="anchor" id="a9feee4b860d9928f86b9d255e2f2b133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Thread::joinable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the thread is joinable. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the thread is joinable.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>All threads are now joinable. </dd></dl>

</div>
</div>
<a class="anchor" id="a87df11cc0a123efafb01a5407af1633a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1Thread.html">Thread</a>&amp; Glib::Thread::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1Thread.html">Thread</a>&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9db6864c35701b1c179f48217ab76cca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1Thread.html">Thread</a>* Glib::Thread::self </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Thread* corresponding to the calling thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The current thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b323f981147d7eb4b4bd03f3fbdccf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Thread::set_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga9b87dca6496b6ad53baec9ca01318448">ThreadPriority</a>&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the priority of the thread to <em>priority</em>. </p>
<dl class="section note"><dt>Note</dt><dd>It is not guaranteed, that threads with different priorities really behave accordingly. On some systems (e.g. Linux) only <code>root</code> can increase priorities. On other systems (e.g. Solaris) there doesn't seem to be different scheduling for different priorities. All in all try to avoid being dependent on priorities. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>A new priority for the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd><a class="el" href="classGlib_1_1Thread.html" title="Represents a running thread. ">Thread</a> priorities no longer have any effect. </dd></dl>

</div>
</div>
<a class="anchor" id="acad8be7a8093ef3aca32344264461011"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Glib::Thread::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives way to other threads waiting to be scheduled. </p>
<p>This function is often used as a method to make busy wait less evil. But in most cases, you will encounter, there are better methods to do that. So in general you shouldn't use this function. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a6bfbb3119eaac9fa8cb725aa1e82f61e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1Thread.html">Thread</a>* wrap </td>
          <td>(</td>
          <td class="paramtype">GThread *&#160;</td>
          <td class="paramname"><em>gobject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>Use Glib::Threads::wrap(GThread*) instead. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 22 2015 11:30:22 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
